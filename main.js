/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ModernMermaidPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  mermaidVersion: "Not loaded",
  transparentMerBackground: true,
  includeBackgroundInCopy: true
};
var ModernMermaidPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.mermaidLoaded = false;
    this.mermaidLoading = false;
    this.mermaidLoadPromise = null;
    this.pluginMermaidInstance = null;
    this.settings = DEFAULT_SETTINGS;
  }
  async onload() {
    console.log("Modern Mermaid plugin loading...");
    await this.loadSettings();
    this.addSettingTab(new ModernMermaidSettingTab(this.app, this));
    window.addEventListener("unhandledrejection", (event) => {
      if (event.reason && event.reason.message && event.reason.message.includes("mermaid")) {
        console.error("Unhandled Mermaid error prevented:", event.reason);
        event.preventDefault();
      }
    });
    try {
      await this.initializeMermaid();
      console.log("Modern Mermaid plugin loaded successfully");
    } catch (error) {
      console.error("Failed to initialize Mermaid:", error);
      new import_obsidian.Notice("Mermaid \uD50C\uB7EC\uADF8\uC778 \uCD08\uAE30\uD654 \uC2E4\uD328");
      return;
    }
    this.registerMarkdownCodeBlockProcessor("mer", async (source, el) => {
      try {
        const backgroundColor = this.settings.transparentMerBackground ? "transparent" : "#ffffff";
        await this.renderMermaid(source, el, "default", backgroundColor);
      } catch (error) {
        console.error("Mermaid code block processor error:", error);
      }
    });
    this.registerMarkdownCodeBlockProcessor("merlight", async (source, el) => {
      try {
        await this.renderMermaid(source, el, "default", "#ffffff");
      } catch (error) {
        console.error("Mermaid code block processor error:", error);
      }
    });
    this.registerMarkdownCodeBlockProcessor("merdark", async (source, el) => {
      try {
        await this.renderMermaid(source, el, "dark", "#000000");
      } catch (error) {
        console.error("Mermaid code block processor error:", error);
      }
    });
  }
  async initializeMermaid() {
    if (this.mermaidLoaded) {
      return;
    }
    if (this.mermaidLoading) {
      if (this.mermaidLoadPromise) {
        await this.mermaidLoadPromise;
      }
      return;
    }
    this.mermaidLoading = true;
    this.mermaidLoadPromise = this.loadMermaid();
    try {
      await this.mermaidLoadPromise;
      this.mermaidLoaded = true;
    } finally {
      this.mermaidLoading = false;
      this.mermaidLoadPromise = null;
    }
  }
  async loadMermaid() {
    console.log("Loading Mermaid...");
    const cached = this.getCache();
    if (cached) {
      console.log("Using cached Mermaid version:", cached.version);
      try {
        await this.loadMermaidFromCode(cached.code, cached.version);
        console.log("Cached Mermaid loaded successfully");
        this.getLatestVersion().then((latestVersion) => {
          if (latestVersion !== cached.version) {
            console.log("New version available:", latestVersion, "- will update");
            this.fetchAndLoadLatest(latestVersion).catch((err) => {
              console.error("Background update failed:", err);
            });
          }
        }).catch((err) => {
          console.error("Failed to check latest version:", err);
        });
        return;
      } catch (error) {
        console.error("Failed to load cached Mermaid:", error);
        this.clearCache();
      }
    }
    console.log("No cache available, fetching latest version");
    try {
      const latestVersion = await this.getLatestVersion();
      await this.fetchAndLoadLatest(latestVersion);
      console.log("Latest Mermaid loaded successfully");
    } catch (error) {
      console.error("Failed to load any Mermaid version:", error);
      throw new Error("Mermaid\uB97C \uB85C\uB4DC\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4. \uC778\uD130\uB137 \uC5F0\uACB0\uC744 \uD655\uC778\uD558\uC138\uC694.");
    }
  }
  async getLatestVersion() {
    console.log("Fetching latest Mermaid version...");
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 5e3);
    try {
      const response = await fetch("https://registry.npmjs.org/mermaid/latest", {
        signal: controller.signal
      });
      clearTimeout(timeout);
      const data = await response.json();
      console.log("Latest version:", data.version);
      return data.version;
    } catch (error) {
      clearTimeout(timeout);
      console.error("Failed to fetch latest version:", error);
      throw error;
    }
  }
  getCache() {
    try {
      const version = localStorage.getItem("modern-mermaid-cached-version");
      const code = localStorage.getItem("modern-mermaid-cached-code");
      if (version && code) {
        return { version, code };
      }
      return null;
    } catch (error) {
      console.error("Failed to load cache:", error);
      return null;
    }
  }
  saveCache(version, code) {
    try {
      localStorage.setItem("modern-mermaid-cached-version", version);
      localStorage.setItem("modern-mermaid-cached-code", code);
    } catch (error) {
      console.error("Failed to save cache:", error);
    }
  }
  clearCache() {
    try {
      localStorage.removeItem("modern-mermaid-cached-version");
      localStorage.removeItem("modern-mermaid-cached-code");
    } catch (error) {
      console.error("Failed to clear cache:", error);
    }
  }
  async fetchAndLoadLatest(version) {
    try {
      const code = await this.fetchMermaidCode(version);
      await this.loadMermaidFromCode(code, version);
      this.saveCache(version, code);
      new import_obsidian.Notice(`Mermaid v${version} \uC5C5\uB370\uC774\uD2B8 \uC644\uB8CC`);
    } catch (error) {
      console.error("Failed to fetch and load latest Mermaid:", error);
      throw error;
    }
  }
  async fetchMermaidCode(version) {
    console.log(`Fetching Mermaid code for version ${version}...`);
    const url = `https://cdn.jsdelivr.net/npm/mermaid@${version}/dist/mermaid.min.js`;
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 3e4);
    try {
      const response = await fetch(url, { signal: controller.signal });
      clearTimeout(timeout);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const code = await response.text();
      console.log(`Mermaid code fetched successfully (${code.length} chars)`);
      return code;
    } catch (error) {
      clearTimeout(timeout);
      console.error("Failed to fetch Mermaid code:", error);
      throw error;
    }
  }
  async loadMermaidFromCode(code, version) {
    console.log(`Loading Mermaid ${version} into DOM...`);
    return new Promise((resolve, reject) => {
      const blob = new Blob([code], { type: "application/javascript" });
      const url = URL.createObjectURL(blob);
      const script = document.createElement("script");
      script.src = url;
      script.id = "mermaid-dynamic-script";
      const timeout = setTimeout(() => {
        console.warn("Mermaid load timeout, checking if available anyway...");
        URL.revokeObjectURL(url);
        if (this.pluginMermaidInstance) {
          try {
            this.pluginMermaidInstance.initialize({ startOnLoad: false });
            resolve();
          } catch (e) {
            reject(new Error("Mermaid initialization failed"));
          }
        } else {
          reject(new Error("Mermaid not loaded after timeout"));
        }
      }, 6e4);
      script.onload = () => {
        console.log("Mermaid script loaded, checking for mermaid object...");
        clearTimeout(timeout);
        URL.revokeObjectURL(url);
        const mermaid = window.mermaid;
        if (mermaid) {
          console.log("Mermaid object found, initializing...");
          this.pluginMermaidInstance = mermaid;
          try {
            mermaid.initialize({ startOnLoad: false });
            console.log("Mermaid initialized successfully");
            this.settings.mermaidVersion = version;
            this.saveSettings();
            resolve();
          } catch (e) {
            console.error("Mermaid initialization failed:", e);
            reject(new Error("Mermaid initialization failed"));
          }
        } else {
          console.error("Mermaid object not found after load");
          reject(new Error("Mermaid not loaded"));
        }
      };
      script.onerror = () => {
        clearTimeout(timeout);
        URL.revokeObjectURL(url);
        console.error("Script error occurred");
        reject(new Error("Failed to load Mermaid from code"));
      };
      console.log("Appending script to head...");
      document.head.appendChild(script);
    });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  parseWidth(source) {
    const lines = source.split("\n");
    const firstLine = lines[0].trim();
    const widthMatch = firstLine.match(/^(\d+)$/);
    if (widthMatch) {
      const width = parseInt(widthMatch[1], 10);
      return { width, source: lines.slice(1).join("\n").trimStart() };
    }
    return { width: null, source };
  }
  async renderMermaid(source, el, theme, backgroundColor) {
    await this.initializeMermaid();
    const mermaid = this.pluginMermaidInstance;
    if (!mermaid) {
      throw new Error("Mermaid not available");
    }
    try {
      const { width, source: actualSource } = this.parseWidth(source);
      const id = "mermaid-" + Math.random().toString(36).substr(2, 9);
      const themeConfig = theme === "dark" ? "dark" : "default";
      mermaid.initialize({ startOnLoad: false, theme: themeConfig });
      let svg;
      try {
        const result = await mermaid.render(id, actualSource);
        svg = result.svg;
      } catch (renderError) {
        console.error("Mermaid render error:", renderError);
        el.innerHTML = `
					<div style="padding: 20px; color: #ef4444; border: 1px solid #ef4444; border-radius: 8px; background-color: rgba(239, 68, 68, 0.1);">
						<strong>Mermaid Rendering Error</strong><br><br>
						${renderError.message}<br><br>
						<small style="color: #6b7280;">Make sure you're using a valid Mermaid diagram type (e.g., graph, sequence, gantt, class, state, er, pie, journey, gitgraph, mindmap, timeline, sankey, block, architecture, requirement)</small>
					</div>
				`;
        return;
      }
      el.innerHTML = svg;
      if (backgroundColor !== "transparent") {
        el.style.backgroundColor = backgroundColor;
      }
      el.style.padding = "20px";
      el.style.borderRadius = "8px";
      el.style.display = "flex";
      el.style.justifyContent = "center";
      el.style.position = "relative";
      if (width) {
        el.style.width = `${width}px`;
        el.style.overflowX = "auto";
      }
      const copyButton = document.createElement("button");
      copyButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/></svg>`;
      copyButton.style.position = "absolute";
      copyButton.style.top = "8px";
      copyButton.style.left = "8px";
      copyButton.style.padding = "6px";
      copyButton.style.backgroundColor = "rgba(128, 128, 128, 0.1)";
      copyButton.style.color = "currentColor";
      copyButton.style.border = "none";
      copyButton.style.borderRadius = "6px";
      copyButton.style.cursor = "pointer";
      copyButton.style.zIndex = "10";
      copyButton.style.transition = "all 0.2s ease";
      copyButton.style.opacity = "0.7";
      copyButton.addEventListener("mouseenter", () => {
        copyButton.style.backgroundColor = "rgba(128, 128, 128, 0.2)";
        copyButton.style.opacity = "1";
      });
      copyButton.addEventListener("mouseleave", () => {
        copyButton.style.backgroundColor = "rgba(128, 128, 128, 0.1)";
        copyButton.style.opacity = "0.7";
      });
      copyButton.addEventListener("click", async () => {
        const originalIcon = copyButton.innerHTML;
        try {
          const svgElement = el.querySelector("svg");
          if (!svgElement) {
            throw new Error("SVG element not found");
          }
          svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg");
          const svgData = new XMLSerializer().serializeToString(svgElement);
          const base64Svg = btoa(unescape(encodeURIComponent(svgData)));
          const url = "data:image/svg+xml;base64," + base64Svg;
          return new Promise((resolve, reject) => {
            const canvas = document.createElement("canvas");
            const img = new Image();
            img.onload = async () => {
              try {
                const bbox = svgElement.getBoundingClientRect();
                canvas.width = Math.ceil((bbox.width || img.width) * 2);
                canvas.height = Math.ceil((bbox.height || img.height) * 2);
                const ctx = canvas.getContext("2d");
                if (!ctx) {
                  throw new Error("Canvas context is null");
                }
                if (this.settings.includeBackgroundInCopy && backgroundColor !== "transparent") {
                  ctx.fillStyle = backgroundColor;
                  ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                canvas.toBlob(async (blob) => {
                  if (blob) {
                    try {
                      await navigator.clipboard.write([new ClipboardItem({ "image/png": blob })]);
                      copyButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg>`;
                      copyButton.style.color = "#10b981";
                      setTimeout(() => {
                        copyButton.innerHTML = originalIcon;
                        copyButton.style.color = "currentColor";
                      }, 1e3);
                      resolve();
                    } catch (clipboardErr) {
                      console.error("Clipboard write failed:", clipboardErr);
                      copyButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>`;
                      copyButton.style.color = "#ef4444";
                      setTimeout(() => {
                        copyButton.innerHTML = originalIcon;
                        copyButton.style.color = "currentColor";
                      }, 1500);
                      reject(clipboardErr);
                    }
                  } else {
                    throw new Error("Blob creation failed");
                  }
                }, "image/png");
              } catch (drawErr) {
                throw drawErr;
              }
            };
            img.onerror = () => {
              copyButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>`;
              copyButton.style.color = "#ef4444";
              setTimeout(() => {
                copyButton.innerHTML = originalIcon;
                copyButton.style.color = "currentColor";
              }, 1500);
              reject(new Error("Image load failed"));
            };
            img.src = url;
          });
        } catch (err) {
          console.error("Copy failed:", err);
          copyButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>`;
          copyButton.style.color = "#ef4444";
          setTimeout(() => {
            copyButton.innerHTML = originalIcon;
            copyButton.style.color = "currentColor";
          }, 1500);
        }
      });
      el.appendChild(copyButton);
    } catch (error) {
      console.error("Unexpected Mermaid error:", error);
      el.innerHTML = `
				<div style="padding: 20px; color: #ef4444; border: 1px solid #ef4444; border-radius: 8px; background-color: rgba(239, 68, 68, 0.1);">
					<strong>Mermaid Rendering Error</strong><br><br>
					${error.message}<br><br>
					<small style="color: #6b7280;">The plugin encountered an unexpected error. Please check the console for details.</small>
				</div>
			`;
    }
  }
  onunload() {
    this.clearCache();
  }
};
var ModernMermaidSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Modern Mermaid Settings" });
    new import_obsidian.Setting(containerEl).setName("Mermaid Version").setDesc("Currently loaded Mermaid library version").addText((text) => text.setDisabled(true).setValue(this.plugin.settings.mermaidVersion));
    new import_obsidian.Setting(containerEl).setName('Transparent Background for "mer"').setDesc('Use transparent background for "mer" code blocks. Disable to use white background.').addToggle((toggle) => toggle.setValue(this.plugin.settings.transparentMerBackground).onChange(async (value) => {
      this.plugin.settings.transparentMerBackground = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Include Background in Copy").setDesc("Include background color when copying as image. Disable to copy only the diagram.").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeBackgroundInCopy).onChange(async (value) => {
      this.plugin.settings.includeBackgroundInCopy = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Clear Cache").setDesc("Clear cached Mermaid library and force re-download").addButton((button) => button.setButtonText("Clear Cache").onClick(async () => {
      this.plugin.clearCache();
      this.plugin.settings.mermaidVersion = "Not loaded";
      await this.plugin.saveSettings();
      new import_obsidian.Notice("Cache cleared. Please reload Obsidian to re-download Mermaid.");
      this.display();
    }));
  }
};
